"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrustedMetadataStore = void 0;
const error_1 = require("./error");
const models_1 = require("./models");
const types_1 = require("./utils/types");
class TrustedMetadataStore {
    constructor(rootData) {
        this.trustedSet = {};
        this.referenceTime = new Date();
        this.loadTrustedRoot(rootData);
    }
    get root() {
        if (!this.trustedSet.root) {
            throw new ReferenceError('No trusted root metadata');
        }
        return this.trustedSet.root;
    }
    get timestamp() {
        return this.trustedSet.timestamp;
    }
    get snapshot() {
        return this.trustedSet.snapshot;
    }
    get targets() {
        return this.trustedSet.targets;
    }
    getRole(name) {
        return this.trustedSet[name];
    }
    updateRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newRoot = models_1.Metadata.fromJSON(types_1.MetadataKind.Root, data);
        if (newRoot.signed.type != types_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);
        }
        this.root.verifyDelegate(types_1.MetadataKind.Root, newRoot);
        if (newRoot.signed.version != this.root.signed.version + 1) {
            throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);
        }
        newRoot.verifyDelegate(types_1.MetadataKind.Root, newRoot);
        this.trustedSet.root = newRoot;
        return newRoot;
    }
    updateTimestamp(bytesBuffer) {
        if (this.snapshot) {
            throw new error_1.RuntimeError('Cannot update timestamp after snapshot');
        }
        if (this.root.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError('Final root.json is expired');
        }
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newTimestamp = models_1.Metadata.fromJSON(types_1.MetadataKind.Timestamp, data);
        if (newTimestamp.signed.type != types_1.MetadataKind.Timestamp) {
            throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);
        }
        this.root.verifyDelegate(types_1.MetadataKind.Timestamp, newTimestamp);
        if (this.timestamp) {
            // Prevent rolling back timestamp version
            if (newTimestamp.signed.version < this.timestamp.signed.version) {
                throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);
            }
            //  Keep using old timestamp if versions are equal.
            if (newTimestamp.signed.version === this.timestamp.signed.version) {
                throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);
            }
            // Prevent rolling back snapshot version
            const snapshotMeta = this.timestamp.signed.snapshotMeta;
            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
            if (newSnapshotMeta.version < snapshotMeta.version) {
                throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);
            }
        }
        // expiry not checked to allow old timestamp to be used for rollback
        // protection of new timestamp: expiry is checked in update_snapshot()
        this.trustedSet.timestamp = newTimestamp;
        this.checkFinalTimestamp();
        return newTimestamp;
    }
    updateSnapshot(bytesBuffer, trusted = false) {
        if (!this.timestamp) {
            throw new error_1.RuntimeError('Cannot update snapshot before timestamp');
        }
        if (this.targets) {
            throw new error_1.RuntimeError('Cannot update snapshot after targets');
        }
        // Snapshot cannot be loaded if final timestamp is expired
        this.checkFinalTimestamp();
        const snapshotMeta = this.timestamp.signed.snapshotMeta;
        // Verify non-trusted data against the hashes in timestamp, if any.
        // Trusted snapshot data has already been verified once.
        if (!trusted) {
            snapshotMeta.verify(bytesBuffer);
        }
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newSnapshot = models_1.Metadata.fromJSON(types_1.MetadataKind.Snapshot, data);
        if (newSnapshot.signed.type != types_1.MetadataKind.Snapshot) {
            throw new error_1.RepositoryError(`Expected 'snapshot', got ${newSnapshot.signed.type}`);
        }
        this.root.verifyDelegate(types_1.MetadataKind.Snapshot, newSnapshot);
        // version not checked against meta version to allow old snapshot to be
        // used in rollback protection: it is checked when targets is updated
        // If an existing trusted snapshot is updated, check for rollback attack
        if (this.snapshot) {
            Object.entries(this.snapshot.signed.meta).forEach(([fileName, fileInfo]) => {
                const newFileInfo = newSnapshot.signed.meta[fileName];
                if (!newFileInfo) {
                    throw new error_1.RepositoryError(`Missing file ${fileName} in new snapshot`);
                }
                if (newFileInfo.version < fileInfo.version) {
                    throw new error_1.BadVersionError(`New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`);
                }
            });
        }
        // expiry not checked to allow old snapshot to be used for rollback
        // protection of new snapshot: it is checked when targets is updated
        this.trustedSet.snapshot = newSnapshot;
        console.log('Updated snapshot v%s', newSnapshot.signed.version);
        // snapshot is loaded, but we raise if it's not valid _final_ snapshot
        this.checkFinalSnapsnot();
        return newSnapshot;
    }
    checkFinalTimestamp() {
        if (!this.timestamp) {
            throw new ReferenceError('No trusted timestamp metadata');
        }
        if (this.timestamp.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError('Final timestamp.json is expired');
        }
    }
    checkFinalSnapsnot() {
        // Raise if snapshot is expired or meta version does not match
        if (!this.snapshot) {
            throw new ReferenceError('No trusted snapshot metadata');
        }
        if (!this.timestamp) {
            throw new ReferenceError('No trusted timestamp metadata');
        }
        if (this.snapshot.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError('snapshot.json is expired');
        }
        const snapshotMeta = this.timestamp.signed.snapshotMeta;
        if (this.snapshot.signed.version !== snapshotMeta.version) {
            throw new error_1.BadVersionError("Snapshot version doesn't match timestamp");
        }
    }
    updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {
        var _a;
        if (!this.snapshot) {
            throw new error_1.RuntimeError('Cannot update delegated targets before snapshot');
        }
        // Targets cannot be loaded if final snapshot is expired or its version
        // does not match meta version in timestamp
        this.checkFinalSnapsnot();
        const delegator = this.trustedSet[delegatorName];
        if (!delegator) {
            throw new error_1.RuntimeError(`No trusted ${delegatorName} metadata`);
        }
        console.log('Updating %s delegated by %s', roleName, delegatorName);
        // Verify against the hashes in snapshot, if any
        const meta = (_a = this.snapshot.signed.meta) === null || _a === void 0 ? void 0 : _a[`${roleName}.json`];
        if (!meta) {
            throw new error_1.RepositoryError(`Missing ${roleName}.json in snapshot`);
        }
        meta.verify(bytesBuffer);
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newDelegate = models_1.Metadata.fromJSON(types_1.MetadataKind.Targets, data);
        if (newDelegate.signed.type != types_1.MetadataKind.Targets) {
            throw new error_1.RepositoryError(`Expected 'targets', got ${newDelegate.signed.type}`);
        }
        delegator.verifyDelegate(roleName, newDelegate);
        const version = newDelegate.signed.version;
        if (version != meta.version) {
            throw new error_1.BadVersionError(`Version ${version} of ${roleName} does not match snapshot version ${meta.version}`);
        }
        if (newDelegate.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(`${roleName}.json is expired`);
        }
        this.trustedSet[roleName] = newDelegate;
        console.log('Updated %s v%s', roleName, version);
    }
    // Verifies and loads data as trusted root metadata.
    // Note that an expired initial root is still considered valid.
    loadTrustedRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const root = models_1.Metadata.fromJSON(types_1.MetadataKind.Root, data);
        if (root.signed.type != types_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(`Expected 'root', got ${root.signed.type}`);
        }
        root.verifyDelegate(types_1.MetadataKind.Root, root);
        this.trustedSet['root'] = root;
        console.info('Loaded trusted root v%d', root.signed.version);
    }
}
exports.TrustedMetadataStore = TrustedMetadataStore;
