"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetFile = exports.MetaFile = void 0;
const crypto_1 = __importDefault(require("crypto"));
const util_1 = __importDefault(require("util"));
const error_1 = require("../error");
const guard_1 = require("../utils/guard");
class MetaFile {
    constructor(opts) {
        if (opts.version <= 0) {
            throw new error_1.ValueError('Metafile version must be at least 1');
        }
        if (opts.length !== undefined) {
            validateLength(opts.length);
        }
        this.version = opts.version;
        this.length = opts.length;
        this.hashes = opts.hashes;
        this.unrecognizedFields = opts.unrecognizedFields || {};
    }
    equals(other) {
        if (!(other instanceof MetaFile)) {
            return false;
        }
        return (this.version === other.version &&
            this.length === other.length &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));
    }
    verify(data) {
        if (this.length !== undefined) {
            verifyLength(data, this.length);
        }
        if (this.hashes) {
            verifyHashes(data, this.hashes);
        }
    }
    toJSON() {
        const json = {
            version: this.version,
            ...this.unrecognizedFields,
        };
        if (this.length !== undefined) {
            json.length = this.length;
        }
        if (this.hashes) {
            json.hashes = this.hashes;
        }
        return json;
    }
    static fromJSON(data) {
        const { version, length, hashes, ...rest } = data;
        if (typeof version !== 'number') {
            throw new TypeError('version must be a number');
        }
        if ((0, guard_1.isDefined)(length) && typeof length !== 'number') {
            throw new TypeError('length must be a number');
        }
        if ((0, guard_1.isDefined)(hashes) && !(0, guard_1.isStringRecord)(hashes)) {
            throw new TypeError('hashes must be string keys and values');
        }
        return new MetaFile({
            version,
            length,
            hashes,
            unrecognizedFields: rest,
        });
    }
}
exports.MetaFile = MetaFile;
// Container for info about a particular target file.
class TargetFile {
    constructor(opts) {
        validateLength(opts.length);
        this.length = opts.length;
        this.path = opts.path;
        this.hashes = opts.hashes;
        this.unrecognizedFields = opts.unrecognizedFields || {};
    }
    get custom() {
        return this.unrecognizedFields['custom'];
    }
    equals(other) {
        if (!(other instanceof TargetFile)) {
            return false;
        }
        return (this.length === other.length &&
            this.path === other.path &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));
    }
    verify(data) {
        verifyLength(data, this.length);
        verifyHashes(data, this.hashes);
    }
    toJSON() {
        return {
            length: this.length,
            hashes: this.hashes,
            ...this.unrecognizedFields,
        };
    }
    static fromJSON(path, data) {
        const { length, hashes, ...rest } = data;
        if (typeof length !== 'number') {
            throw new TypeError('length must be a number');
        }
        if (!(0, guard_1.isStringRecord)(hashes)) {
            throw new TypeError('hashes must have string keys and values');
        }
        return new TargetFile({
            length,
            path,
            hashes,
            unrecognizedFields: rest,
        });
    }
}
exports.TargetFile = TargetFile;
// Verifies that the given data matches the supplied hashes.
function verifyHashes(data, hashes) {
    Object.entries(hashes).forEach(([key, value]) => {
        let hash;
        try {
            hash = crypto_1.default.createHash(key);
        }
        catch (e) {
            throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);
        }
        const observedHash = hash.update(data).digest('hex');
        if (observedHash !== value) {
            throw new error_1.LengthOrHashMismatchError(`Expected hash ${value} but got ${observedHash}`);
        }
    });
}
// Verifies that the given data matches the expected length.
function verifyLength(data, expectedLength) {
    const observedLength = data.length;
    if (observedLength !== expectedLength) {
        throw new error_1.LengthOrHashMismatchError(`Expected length ${expectedLength} but got ${observedLength}`);
    }
}
// Check that supplied length if valid
function validateLength(length) {
    if (length < 0) {
        throw new error_1.ValueError('Length must be at least 0');
    }
}
